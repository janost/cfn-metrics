AWSTemplateFormatVersion: "2010-09-09"
Description: Metrics ingest stack with Grafana, InfluxDB, etc.

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: Network
        Parameters: [InstanceAZ, SSHLocation]
      - Label:
          default: EC2 instance
        Parameters: [CreateEC2Instance, AttachDataVolume, InstanceType, InstanceAMI, KeyName, EC2InstanceRootDiskSize, InstanceDataDiskSize, EC2InstanceSwapDiskSize]

Parameters:
  InstanceAZ:
    Description: Availability zone for the EC2 instance.
    Type: AWS::EC2::AvailabilityZone::Name
  InstanceType:
    Description: EC2 instance type of the EC2 instance.
    Type: String
    Default: t2.micro
  InstanceAMI:
    Description: Instance AMI to build the EC2 instance from (generated by packer from `base-image.json`).
    Type: AWS::EC2::Image::Id
    Default: ami-058a5cf5f43150809
  KeyName:
    Description: EC2 KeyPair to enable SSH access to the EC2 instance.
    Type: AWS::EC2::KeyPair::KeyName
  CreateEC2Instance:
    Description: Cycle false/true on this property to replace your EC2 instance. WARNING! Setting this to true will DESTROY your instance!
    Type: String
    AllowedValues: [true, false]
    Default: true
  EC2InstanceRootDiskSize:
    Description: Size of the EC2 instance's root disk
    Type: Number
    Default: 8
  InstanceDataDiskSize:
    Description:  Size of the EC2 instance's data EBS volume.
    Type: Number
    Default: 10
  EC2InstanceSwapDiskSize:
    Description:  Size of the EC2 instance's swap EBS volume.
    Type: Number
    Default: 4
  SSHLocation:
    Description: The IP address range that can be used to SSH to the EC2 instance.
    Type: String
    MinLength: 9
    MaxLength: 18
    Default: "0.0.0.0/0"
    AllowedPattern: "(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})/(\\d{1,2})"
  AttachDataVolume:
    Description: Attach data volume to the EC2 instance. This is here because VolumeAttachments can't be updated, so you can't replace the EC2 instance while this attachment exists.
    Type: String
    AllowedValues: [true, false]
    Default: true

Conditions:
  cAttachDataVolume: !And [ !Equals [ !Ref CreateEC2Instance, true ], !Equals [ !Ref AttachDataVolume, true ] ]
  cCreateEC2Instance: !Equals [ !Ref CreateEC2Instance, true ]

Resources:
  MainVPC:
    Type: AWS::EC2::VPC
    Properties:
      Tags:
      - Key: Name
        Value: !Join ['-', [!Ref 'AWS::StackName', VPC]]
      CidrBlock: '10.2.0.0/16'
      EnableDnsSupport: true
      EnableDnsHostnames: true

  MainIGW:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
      - Key: Name
        Value: !Join ['-', [!Ref 'AWS::StackName', MainIGW]]

  MainIGWAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      InternetGatewayId: !Ref MainIGW
      VpcId: !Ref MainVPC

  PublicSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: !Ref InstanceAZ
      CidrBlock: '10.2.1.0/24'
      MapPublicIpOnLaunch: true
      Tags:
      - Key: Name
        Value: !Join ['-', [!Ref 'AWS::StackName', PublicSubnet1]]
      VpcId: !Ref MainVPC

  PublicRouteTable1:
    Type: AWS::EC2::RouteTable
    DependsOn: MainIGW
    Properties:
      Tags:
      - Key: Name
        Value: !Join ['-', [!Ref 'AWS::StackName', PublicRouteTable1]]
      VpcId: !Ref MainVPC

  PublicRouteTableAssociation1:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PublicRouteTable1
      SubnetId: !Ref PublicSubnet1

  PublicIGWRoute1:
    Type: AWS::EC2::Route
    Properties:
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref MainIGW
      RouteTableId: !Ref PublicRouteTable1

  InstanceDataVolume:
    Type: AWS::EC2::Volume
    Properties:
      AvailabilityZone: !Ref InstanceAZ
      VolumeType: gp2
      Encrypted: true
      KmsKeyId: !GetAtt EncryptionKey.Arn
      Size: !Ref InstanceDataDiskSize
      Tags:
        - Key: Name
          Value: !Join ['-', [!Ref 'AWS::StackName', InstanceDataVolume]]

  InstanceDataVolumeAttachment:
    Condition: cAttachDataVolume
    Type: AWS::EC2::VolumeAttachment
    Properties:
      Device: '/dev/xvdb'
      InstanceId: !Ref EC2Instance
      VolumeId: !Ref InstanceDataVolume

  EC2InstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - ec2.amazonaws.com
          Action:
          - sts:AssumeRole
      Path: /
      Policies:
      - PolicyName: LogPolicy
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action:
            - logs:CreateLogGroup
            - logs:CreateLogStream
            - logs:PutLogEvents
            - logs:DescribeLogStreams
            Resource: arn:aws:logs:*:*:*
      - PolicyName: EC2VolumeTagPolicy
        PolicyDocument:
          Version: '2012-10-17'
          Statement:
          - Effect: Allow
            Action: ec2:DescribeVolumes
            Resource: '*'
          - Effect: Allow
            Action: ec2:CreateTags
            Resource: arn:aws:ec2:*:*:volume/*

  EC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles:
      - !Ref EC2InstanceRole

  EC2Instance:
    Condition: cCreateEC2Instance
    Type: AWS::EC2::Instance
    Properties:
      AvailabilityZone: !Ref InstanceAZ
      ImageId: !Ref InstanceAMI
      InstanceType: !Ref InstanceType
      KeyName: !Ref KeyName
      IamInstanceProfile: !Ref EC2InstanceProfile
      BlockDeviceMappings:
        - DeviceName: '/dev/sda1'
          Ebs:
            VolumeType: gp2
            Encrypted: true
            DeleteOnTermination: true
            VolumeSize: !Ref EC2InstanceRootDiskSize
        - DeviceName: '/dev/xvds'
          Ebs:
            VolumeType: gp2
            Encrypted: true
            DeleteOnTermination: true
            VolumeSize: !Ref EC2InstanceSwapDiskSize
      Tags:
        - Key: Stack
          Value: !Ref 'AWS::StackId'
        - Key: Name
          Value: !Join ['-', [!Ref 'AWS::StackName', EC2Instance]]
      SecurityGroupIds: [ !Ref EC2InstanceSecurityGroup ]
      SubnetId: !Ref PublicSubnet1
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash

          /opt/aws/bin/cfn-init -v --stack ${AWS::StackName} --resource EC2Instance --region ${AWS::Region}

          DATA_DEVICE="/dev/xvdb"
          SWAP_DEVICE="/dev/xvds"
          DATA_MOUNTPOINT="/data"

          echo "Getting metadata from AWS API...."
          INSTANCE_ID=$(curl -s http://169.254.169.254/latest/meta-data/instance-id)
          PUBLIC_IPV4=$(curl http://169.254.169.254/latest/meta-data/public-ipv4)
          AVAIL_ZONE=$(curl http://169.254.169.254/latest/meta-data/placement/availability-zone)
          AWS_REGION="$(echo $AVAIL_ZONE | sed 's/.$//')"

          /var/awslogs/bin/aws configure set default.region $AWS_REGION

          echo "Tagging our volumes..."
          ROOT_VOLUME=$(/var/awslogs/bin/aws ec2 describe-volumes --query 'Volumes[*].VolumeId' --filters Name=attachment.instance-id,Values=$INSTANCE_ID Name=attachment.device,Values=/dev/xvda --output text)
          DATA_VOLUME=$(/var/awslogs/bin/aws ec2 describe-volumes --query 'Volumes[*].VolumeId' --filters Name=attachment.instance-id,Values=$INSTANCE_ID Name=attachment.device,Values=$DATA_DEVICE --output text)
          SWAP_VOLUME=$(/var/awslogs/bin/aws ec2 describe-volumes --query 'Volumes[*].VolumeId' --filters Name=attachment.instance-id,Values=$INSTANCE_ID Name=attachment.device,Values=$SWAP_DEVICE --output text)
          /var/awslogs/bin/aws ec2 create-tags --resources $ROOT_VOLUME --tags Key=Name,Value=${AWS::StackName}-$INSTANCE_ID-root
          /var/awslogs/bin/aws ec2 create-tags --resources $DATA_VOLUME --tags Key=Name,Value=${AWS::StackName}-$INSTANCE_ID-data
          /var/awslogs/bin/aws ec2 create-tags --resources $SWAP_VOLUME --tags Key=Name,Value=${AWS::StackName}-$INSTANCE_ID-swap

          if grep -q "init done" /etc/fstab; then
            echo "Filesystems have been already initialized. Skipping..."
          else
            echo "Setting up data partition..."
            if [ -b "$DATA_DEVICE" ]; then
              if file -sL $DATA_DEVICE | grep -q 'ext4 filesystem data'; then
                echo "There's already an ext4 filesystem on $DATA_DEVICE."
              else
                echo "No filesystem on $DATA_DEVICE. Formatting..."
                mkfs.ext4 "$DATA_DEVICE"
                echo "Format done."
              fi
            else
              echo "ERROR: $DATA_DEVICE doesn't seem to be a block device."
            fi

            echo "Setting up swap..."
            if [ -b "$SWAP_DEVICE" ]; then
              mkswap "$SWAP_DEVICE"
            else
              echo "$SWAP_DEVICE is not a block device. Aborting..."
            fi

            echo "Flagging fstab..."
            echo "# init done" >> /etc/fstab

            echo "Mounting partitions..."
            mount -a
            swapon -a
            mount
            swapon -s
          fi

          function external_dir() {
            local LOCAL_DIR="$1"
            local EXTERNAL_DIR="$DATA_MOUNTPOINT$LOCAL_DIR"

            echo "external_dir(): $LOCAL_DIR --> $EXTERNAL_DIR"

            if readlink $LOCAL_DIR; then
              echo "$LOCAL_DIR is already a symlink."
              EXTERNAL_DIR_RESULT="false"
            else
              if [ -d "$EXTERNAL_DIR" ]; then
                echo "$EXTERNAL_DIR already exists, skipping move and removing $LOCAL_DIR..."
                rm -rf "$LOCAL_DIR"
              else
                echo "Current contents of $LOCAL_DIR:"
                ls -lah "$LOCAL_DIR"
                echo "Moving $LOCAL_DIR to $EXTERNAL_DIR..."
                mkdir -p "$EXTERNAL_DIR"
                shopt -s dotglob
                mv $LOCAL_DIR/* "$EXTERNAL_DIR/"
                rm -rf "$LOCAL_DIR"
              fi
              echo "Linking $EXTERNAL_DIR to $LOCAL_DIR..."
              ln -s "$EXTERNAL_DIR" "$LOCAL_DIR"
              EXTERNAL_DIR_RESULT="true"
            fi
          }

          if mountpoint -q $DATA_MOUNTPOINT; then
            external_dir "/etc/telegraf"
            external_dir "/etc/influxdb"
            external_dir "/var/lib/influxdb"
            external_dir "/etc/grafana"
            external_dir "/var/lib/grafana"
            external_dir "/etc/letsencrypt"
            external_dir "/srv/www"
            external_dir "/etc/nginx"
            if [ "$EXTERNAL_DIR_RESULT" == "true" ]; then
              systemctl restart nginx
            fi
            external_dir "/var/awslogs/etc"
            if [ "$EXTERNAL_DIR_RESULT" == "true" ]; then
              systemctl restart awslogs
            fi
            systemctl enable --now telegraf
            systemctl enable --now influxdb
            systemctl enable --now grafana-server

            INSTANCE_REBUILD_SCRIPT="$DATA_MOUNTPOINT/instance-rebuild.sh"
            if [ -x "$INSTANCE_REBUILD_SCRIPT" ]; then
              echo "Executing instance rebuild script ($INSTANCE_REBUILD_SCRIPT)"
              $INSTANCE_REBUILD_SCRIPT
            else
              echo "No instance rebuild script found ($INSTANCE_REBUILD_SCRIPT), skipping..."
            fi
          else
            echo "ERROR: $DATA_MOUNTPOINT is still not mounted. The instance is broken, you have to fix this manually."
          fi

          /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackName} --resource EC2Instance --region ${AWS::Region}
    Metadata:
      AWS::CloudFormation::Init:
        config:
          files:
            /etc/cfn/cfn-hup.conf:
              content: !Sub |
                [main]
                stack=${AWS::StackId}
                region=${AWS::Region}
                verbose=true
                interval=5
              mode: "000400"
              owner: root
              group: root
            /etc/cfn/hooks.d/cfn-auto-reloader.conf:
              content: !Sub |
                [cfn-auto-reloader-hook]
                triggers=post.update
                path=Resources.EC2Instance.Metadata.AWS::CloudFormation::Init
                action=/opt/aws/bin/cfn-init -v --stack ${AWS::StackName} --resource EC2Instance --region ${AWS::Region}
              mode: "000400"
              owner: root
              group: root
            /etc/systemd/system/cfn-hup.service:
              content: |
                [Unit]
                Description=cfn-hup daemon

                [Service]
                Type=simple
                ExecStart=/opt/aws/bin/cfn-hup
                Restart=always

                [Install]
                WantedBy=multi-user.target
              mode: "000400"
              owner: root
              group: root
            /var/awslogs/etc/config/system-logs.conf:
              mode: "000600"
              owner: root
              group: root
              content: !Sub |
                [/var/log/auth.log]
                log_group_name = ${AWS::StackName}/var/log/auth.log
                log_stream_name = {instance_id}
                file = /var/log/auth.log
            /opt/generate-hosting-env.sh:
              mode: "000700"
              owner: root
              group: root
              content: |
                #!/bin/bash

                HOSTING_ENV_FILE="/etc/wsman-sites/hosting-env"

                mkdir -p $(dirname $HOSTING_ENV_FILE)

                INSTANCE_ID=$(curl -s http://169.254.169.254/latest/meta-data/instance-id)
                PUBLIC_IPV4=$(curl http://169.254.169.254/latest/meta-data/public-ipv4)
                AVAIL_ZONE=$(curl http://169.254.169.254/latest/meta-data/placement/availability-zone)
                AWS_REGION="$(echo $AVAIL_ZONE | sed 's/.$//')"

                echo "INSTANCE_ID=$INSTANCE_ID" > $HOSTING_ENV_FILE
                echo "PUBLIC_IPV4=$PUBLIC_IPV4" >> $HOSTING_ENV_FILE
                echo "AVAIL_ZONE=$AVAIL_ZONE" >> $HOSTING_ENV_FILE
                echo "AWS_REGION=$AWS_REGION" >> $HOSTING_ENV_FILE

                chmod 0400 $HOSTING_ENV_FILE
            /opt/stack-name.sh:
              mode: "000700"
              owner: root
              group: root
              content: !Sub |
                #!/bin/bash

                echo "${AWS::StackName}"
          commands:
            01_enable_start_cfn-hup:
              command: "systemctl enable --now cfn-hup"
            02_restart_awslogs:
              command: "systemctl restart awslogs"
            03_hosting_env:
              command: "/opt/generate-hosting-env.sh"

  EC2InstanceSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: EC2 instance security group
      VpcId: !Ref MainVPC
      SecurityGroupIngress:
        - CidrIp: !Ref SSHLocation
          IpProtocol: tcp
          FromPort: 22
          ToPort: 22
        - CidrIp: "0.0.0.0/0"
          IpProtocol: tcp
          FromPort: 80
          ToPort: 80
        - CidrIp: "0.0.0.0/0"
          IpProtocol: tcp
          FromPort: 443
          ToPort: 443

  EC2InstanceEIP:
    Type: AWS::EC2::EIP
    Properties:
      Domain: vpc

  EC2InstanceEIPAssociation:
    Condition: cCreateEC2Instance
    Type: AWS::EC2::EIPAssociation
    Properties:
      AllocationId: !GetAtt EC2InstanceEIP.AllocationId
      InstanceId: !Ref EC2Instance

  EncryptionKey:
    Type: AWS::KMS::Key
    Properties:
      Description: This key is used to encrypt the RDS database and EBS volumes of the web stack.
      Enabled: true
      EnableKeyRotation: false
      KeyPolicy:
        Version: "2012-10-17"
        Id: "key-default-1"
        Statement:
          - Sid: "Enable IAM User Permissions"
            Effect: Allow
            Principal:
              AWS: !Join ['', ['arn:aws:iam::', !Ref 'AWS::AccountId', ':root']]
            Action: "kms:*"
            Resource: "*"
          - Sid: "Allow access for Key Administrators"
            Effect: Allow
            Principal:
              AWS: !Join ['', ['arn:aws:iam::', !Ref 'AWS::AccountId', ':root']]
            Action: "kms:*"
            Resource: "*"

  EncryptionKeyAlias:
    Type: AWS::KMS::Alias
    Properties:
      AliasName: !Join ['', ['alias/', !Ref 'AWS::StackName', '-key']]
      TargetKeyId:
        Ref: EncryptionKey

Outputs:
  EC2InstanceIP:
    Condition: cCreateEC2Instance
    Description: Elastic IP address of the EC2 instance. Set A records to point to this IP address.
    Value: !GetAtt EC2Instance.PublicIp
